(function ()
{

    /**
 * Tessellates the famous Utah teacup database by Martin Newell into triangles.
 *
 * Parameters: size = 50, segments = 10, bottom = true, lid = true, body = true,
 *   fitLid = false, blinn = true
 */

    class TeacupGeometry extends THREE.BufferGeometry
    {

        constructor(size = 50, segments = 10)
        {
            // 26 * 4 * 4 Bezier spline patches, note +1 start
            // Data from ftp://ftp.funet.fi/pub/sci/graphics/packages/objects/teaset.tar.Z
            const teacupPatches = [
                1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
                4, 17, 18, 19, 8, 20, 21, 22, 12, 23, 24, 25, 16, 26, 27, 28,
                19, 29, 30, 31, 22, 32, 33, 34, 25, 35, 36, 37, 28, 38, 39, 40,
                31, 41, 42, 1, 34, 43, 44, 5, 37, 45, 46, 9, 40, 47, 48, 13,
                13, 14, 15, 16, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60,
                16, 26, 27, 28, 52, 61, 62, 63, 56, 64, 65, 66, 60, 67, 68, 69,
                28, 38, 39, 40, 63, 70, 71, 72, 66, 73, 74, 75, 69, 76, 77, 78,
                40, 47, 48, 13, 72, 79, 80, 49, 75, 81, 82, 53, 78, 83, 84, 57,
                193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 1, 2, 3, 4,
                196, 205, 206, 207, 200, 208, 209, 210, 204, 211, 212, 213, 4, 17, 18, 19,
                207, 214, 215, 216, 210, 217, 218, 219, 213, 220, 221, 222, 19, 29, 30, 31,
                216, 223, 224, 193, 219, 225, 226, 197, 222, 227, 228, 201, 31, 41, 42, 1,
                229, 230, 231, 28, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243,
                28, 244, 245, 229, 235, 246, 247, 232, 239, 248, 249, 236, 243, 250, 251, 240,
                57, 58, 59, 60, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96,
                60, 67, 68, 69, 88, 97, 98, 99, 92, 100, 101, 102, 96, 103, 104, 105,
                69, 76, 77, 78, 99, 106, 107, 108, 102, 109, 110, 111, 105, 112, 113, 114,
                78, 83, 84, 57, 108, 115, 116, 85, 111, 117, 118, 89, 114, 119, 120, 93,
                93, 94, 95, 96, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132,
                96, 103, 104, 105, 124, 133, 134, 135, 128, 136, 137, 138, 132, 139, 140, 141,
                105, 112, 113, 114, 135, 142, 143, 144, 138, 145, 146, 147, 141, 148, 149, 150,
                114, 119, 120, 93, 144, 151, 152, 121, 147, 153, 154, 125, 150, 155, 156, 129,
                129, 130, 131, 132, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168,
                132, 139, 140, 141, 160, 169, 170, 171, 164, 172, 173, 174, 168, 175, 176, 177,
                141, 148, 149, 150, 171, 178, 179, 180, 174, 181, 182, 183, 177, 184, 185, 186,
                150, 155, 156, 129, 180, 187, 188, 157, 183, 189, 190, 161, 186, 191, 192, 165
            ];

            const teacupVertices = [
                0.409091, 0.772727, 0.0,
                0.409091, 0.772727, -0.229091,
                0.229091, 0.772727, -0.409091,
                0.0, 0.772727, -0.409091,
                0.409091, 0.886364, 0.0,
                0.409091, 0.886364, -0.229091,
                0.229091, 0.886364, -0.409091,
                0.0, 0.886364, -0.409091,
                0.454545, 0.886364, 0.0,
                0.454545, 0.886364, -0.254545,
                0.254545, 0.886364, -0.454545,
                0.0, 0.886364, -0.454545,
                0.454545, 0.772727, 0.0,
                0.454545, 0.772727, -0.254545,
                0.254545, 0.772727, -0.454545,
                0.0, 0.772727, -0.454545,
                -0.229091, 0.772727, -0.409091,
                -0.409091, 0.772727, -0.229091,
                -0.409091, 0.772727, 0.0,
                -0.229091, 0.886364, -0.409091,
                -0.409091, 0.886364, -0.229091,
                -0.409091, 0.886364, 0.0,
                -0.254545, 0.886364, -0.454545,
                -0.454545, 0.886364, -0.254545,
                -0.454545, 0.886364, 0.0,
                -0.254545, 0.772727, -0.454545,
                -0.454545, 0.772727, -0.254545,
                -0.454545, 0.772727, 0.0,
                -0.409091, 0.772727, 0.229091,
                -0.229091, 0.772727, 0.409091,
                0.0, 0.772727, 0.409091,
                -0.409091, 0.886364, 0.229091,
                -0.229091, 0.886364, 0.409091,
                0.0, 0.886364, 0.409091,
                -0.454545, 0.886364, 0.254545,
                -0.254545, 0.886364, 0.454545,
                0.0, 0.886364, 0.454545,
                -0.454545, 0.772727, 0.254545,
                -0.254545, 0.772727, 0.454545,
                0.0, 0.772727, 0.454545,
                0.229091, 0.772727, 0.409091,
                0.409091, 0.772727, 0.229091,
                0.229091, 0.886364, 0.409091,
                0.409091, 0.886364, 0.229091,
                0.254545, 0.886364, 0.454545,
                0.454545, 0.886364, 0.254545,
                0.254545, 0.772727, 0.454545,
                0.454545, 0.772727, 0.254545,
                0.454545, 0.545455, 0.0,
                0.454545, 0.545455, -0.254545,
                0.254545, 0.545455, -0.454545,
                0.0, 0.545455, -0.454545,
                0.454545, 0.272727, 0.0,
                0.454545, 0.272727, -0.254545,
                0.254545, 0.272727, -0.454545,
                0.0, 0.272727, -0.454545,
                0.318182, 0.0454545, 0.0,
                0.318182, 0.0454545, -0.178182,
                0.178182, 0.0454545, -0.318182,
                0.0, 0.0454545, -0.318182,
                -0.254545, 0.545455, -0.454545,
                -0.454545, 0.545455, -0.254545,
                -0.454545, 0.545455, 0.0,
                -0.254545, 0.272727, -0.454545,
                -0.454545, 0.272727, -0.254545,
                -0.454545, 0.272727, 0.0,
                -0.178182, 0.0454545, -0.318182,
                -0.318182, 0.0454545, -0.178182,
                -0.318182, 0.0454545, 0.0,
                -0.454545, 0.545455, 0.254545,
                -0.254545, 0.545455, 0.454545,
                0.0, 0.545455, 0.454545,
                -0.454545, 0.272727, 0.254545,
                -0.254545, 0.272727, 0.454545,
                0.0, 0.272727, 0.454545,
                -0.318182, 0.0454545, 0.178182,
                -0.178182, 0.0454545, 0.318182,
                0.0, 0.0454545, 0.318182,
                0.254545, 0.545455, 0.454545,
                0.454545, 0.545455, 0.254545,
                0.254545, 0.272727, 0.454545,
                0.454545, 0.272727, 0.254545,
                0.178182, 0.0454545, 0.318182,
                0.318182, 0.0454545, 0.178182,
                0.545455, 0.0454545, 0.0,
                0.545455, 0.0454545, -0.305455,
                0.305455, 0.0454545, -0.545455,
                0.0, 0.0454545, -0.545455,
                0.727273, 0.136364, 0.0,
                0.727273, 0.136364, -0.407273,
                0.407273, 0.136364, -0.727273,
                0.0, 0.136364, -0.727273,
                0.909091, 0.136364, 0.0,
                0.909091, 0.136364, -0.509091,
                0.509091, 0.136364, -0.909091,
                0.0, 0.136364, -0.909091,
                -0.305455, 0.0454545, -0.545455,
                -0.545455, 0.0454545, -0.305455,
                -0.545455, 0.0454545, 0.0,
                -0.407273, 0.136364, -0.727273,
                -0.727273, 0.136364, -0.407273,
                -0.727273, 0.136364, 0.0,
                -0.509091, 0.136364, -0.909091,
                -0.909091, 0.136364, -0.509091,
                -0.909091, 0.136364, 0.0,
                -0.545455, 0.0454545, 0.305455,
                -0.305455, 0.0454545, 0.545455,
                0.0, 0.0454545, 0.545455,
                -0.727273, 0.136364, 0.407273,
                -0.407273, 0.136364, 0.727273,
                0.0, 0.136364, 0.727273,
                -0.909091, 0.136364, 0.509091,
                -0.509091, 0.136364, 0.909091,
                0.0, 0.136364, 0.909091,
                0.305455, 0.0454545, 0.545455,
                0.545455, 0.0454545, 0.305455,
                0.407273, 0.136364, 0.727273,
                0.727273, 0.136364, 0.407273,
                0.509091, 0.136364, 0.909091,
                0.909091, 0.136364, 0.509091,
                1.0, 0.136364, 0.0,
                1.0, 0.136364, -0.56,
                0.56, 0.136364, -1.0,
                0.0, 0.136364, -1.0,
                1.0, 0.0909091, 0.0,
                1.0, 0.0909091, -0.56,
                0.56, 0.0909091, -1.0,
                0.0, 0.0909091, -1.0,
                0.909091, 0.0909091, 0.0,
                0.909091, 0.0909091, -0.509091,
                0.509091, 0.0909091, -0.909091,
                0.0, 0.0909091, -0.909091,
                -0.56, 0.136364, -1.0,
                -1.0, 0.136364, -0.56,
                -1.0, 0.136364, 0.0,
                -0.56, 0.0909091, -1.0,
                -1.0, 0.0909091, -0.56,
                -1.0, 0.0909091, 0.0,
                -0.509091, 0.0909091, -0.909091,
                -0.909091, 0.0909091, -0.509091,
                -0.909091, 0.0909091, 0.0,
                -1.0, 0.136364, 0.56,
                -0.56, 0.136364, 1.0,
                0.0, 0.136364, 1.0,
                -1.0, 0.0909091, 0.56,
                -0.56, 0.0909091, 1.0,
                0.0, 0.0909091, 1.0,
                -0.909091, 0.0909091, 0.509091,
                -0.509091, 0.0909091, 0.909091,
                0.0, 0.0909091, 0.909091,
                0.56, 0.136364, 1.0,
                1.0, 0.136364, 0.56,
                0.56, 0.0909091, 1.0,
                1.0, 0.0909091, 0.56,
                0.509091, 0.0909091, 0.909091,
                0.909091, 0.0909091, 0.509091,
                0.727273, 0.0909091, 0.0,
                0.727273, 0.0909091, -0.407273,
                0.407273, 0.0909091, -0.727273,
                0.0, 0.0909091, -0.727273,
                0.545455, 0.0, 0.0,
                0.545455, 0.0, -0.305455,
                0.305455, 0.0, -0.545455,
                0.0, 0.0, -0.545455,
                0.318182, 0.0, 0.0,
                0.318182, 0.0, -0.178182,
                0.178182, 0.0, -0.318182,
                0.0, 0.0, -0.318182,
                -0.407273, 0.0909091, -0.727273,
                -0.727273, 0.0909091, -0.407273,
                -0.727273, 0.0909091, 0.0,
                -0.305455, 0.0, -0.545455,
                -0.545455, 0.0, -0.305455,
                -0.545455, 0.0, 0.0,
                -0.178182, 0.0, -0.318182,
                -0.318182, 0.0, -0.178182,
                -0.318182, 0.0, 0.0,
                -0.727273, 0.0909091, 0.407273,
                -0.407273, 0.0909091, 0.727273,
                0.0, 0.0909091, 0.727273,
                -0.545455, 0.0, 0.305455,
                -0.305455, 0.0, 0.545455,
                0.0, 0.0, 0.545455,
                -0.318182, 0.0, 0.178182,
                -0.178182, 0.0, 0.318182,
                0.0, 0.0, 0.318182,
                0.407273, 0.0909091, 0.727273,
                0.727273, 0.0909091, 0.407273,
                0.305455, 0.0, 0.545455,
                0.545455, 0.0, 0.305455,
                0.178182, 0.0, 0.318182,
                0.318182, 0.0, 0.178182,
                0.272727, 0.0454545, 0.0,
                0.272727, 0.0454545, -0.152727,
                0.152727, 0.0454545, -0.272727,
                0.0, 0.0454545, -0.272727,
                0.409091, 0.272727, 0.0,
                0.409091, 0.272727, -0.229091,
                0.229091, 0.272727, -0.409091,
                0.0, 0.272727, -0.409091,
                0.409091, 0.545455, 0.0,
                0.409091, 0.545455, -0.229091,
                0.229091, 0.545455, -0.409091,
                0.0, 0.545455, -0.409091,
                -0.152727, 0.0454545, -0.272727,
                -0.272727, 0.0454545, -0.152727,
                -0.272727, 0.0454545, 0.0,
                -0.229091, 0.272727, -0.409091,
                -0.409091, 0.272727, -0.229091,
                -0.409091, 0.272727, 0.0,
                -0.229091, 0.545455, -0.409091,
                -0.409091, 0.545455, -0.229091,
                -0.409091, 0.545455, 0.0,
                -0.272727, 0.0454545, 0.152727,
                -0.152727, 0.0454545, 0.272727,
                0.0, 0.0454545, 0.272727,
                -0.409091, 0.272727, 0.229091,
                -0.229091, 0.272727, 0.409091,
                0.0, 0.272727, 0.409091,
                -0.409091, 0.545455, 0.229091,
                -0.229091, 0.545455, 0.409091,
                0.0, 0.545455, 0.409091,
                0.152727, 0.0454545, 0.272727,
                0.272727, 0.0454545, 0.152727,
                0.229091, 0.272727, 0.409091,
                0.409091, 0.272727, 0.229091,
                0.229091, 0.545455, 0.409091,
                0.409091, 0.545455, 0.229091,
                -0.454545, 0.704545, 0.0,
                -0.454545, 0.704545, -0.0454545,
                -0.454545, 0.772727, -0.0454545,
                -0.772727, 0.863636, 0.0,
                -0.772727, 0.863636, -0.0454545,
                -0.818182, 0.954545, -0.0454545,
                -0.818182, 0.954545, 0.0,
                -0.772727, 0.522727, 0.0,
                -0.772727, 0.522727, -0.0454545,
                -0.909091, 0.477273, -0.0454545,
                -0.909091, 0.477273, 0.0,
                -0.409091, 0.363636, 0.0,
                -0.409091, 0.363636, -0.0454545,
                -0.409091, 0.295455, -0.0454545,
                -0.409091, 0.295455, 0.0,
                -0.454545, 0.772727, 0.0454545,
                -0.454545, 0.704545, 0.0454545,
                -0.818182, 0.954545, 0.0454545,
                -0.772727, 0.863636, 0.0454545,
                -0.909091, 0.477273, 0.0454545,
                -0.772727, 0.522727, 0.0454545,
                -0.409091, 0.295455, 0.0454545,
                -0.409091, 0.363636, 0.0454545
            ];
            super(); // number of segments per patch

            segments = Math.max(2, Math.floor(segments));

            const maxHeight = 0.857954740524292;
            const maxHeight2 = maxHeight / 2;
            const trueSize = size / maxHeight2; // Number of elements depends on what is needed. Subtract degenerate

            let numTriangles = 26 * 2 * segments * segments;
            const indices = new Uint32Array(numTriangles * 3);
            let numVertices = 251;
            numVertices *= (segments + 1) * (segments + 1);
            const vertices = new Float32Array(numVertices * 3);
            const normals = new Float32Array(numVertices * 3);
            const uvs = new Float32Array(numVertices * 2); // Bezier form

            const ms = new THREE.Matrix4();
            ms.set(-1.0, 3.0, -3.0, 1.0, 3.0, -6.0, 3.0, 0.0, -3.0, 3.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0);

            const g = [];
            const sp = [];
            const tp = [];
            const dsp = [];
            const dtp = []; // M * G * M matrix, sort of see

            // http://www.cs.helsinki.fi/group/goa/mallinnus/curves/surfaces.html
            const mgm = [];
            const vert = [];
            const sdir = [];
            const tdir = [];
            const norm = new THREE.Vector3();

            let tcoord;
            let sval;
            let tval;
            let p;
            let dsval = 0;
            let dtval = 0;

            const normOut = new THREE.Vector3();
            const gmx = new THREE.Matrix4();
            const tmtx = new THREE.Matrix4();
            const vsp = new THREE.Vector4();
            const vtp = new THREE.Vector4();
            const vdsp = new THREE.Vector4();
            const vdtp = new THREE.Vector4();
            const vsdir = new THREE.Vector3();
            const vtdir = new THREE.Vector3();

            const mst = ms.clone();
            // internal function: test if triangle has any matching vertices;
            // if so, don't save triangle, since it won't display anything.
            mst.transpose();

            const notDegenerate = (vtx1, vtx2, vtx3) => // if any vertex matches, return false
                !(vertices[vtx1 * 3] === vertices[vtx2 * 3] && vertices[vtx1 * 3 + 1] === vertices[vtx2 * 3 + 1] && vertices[vtx1 * 3 + 2] === vertices[vtx2 * 3 + 2] || vertices[vtx1 * 3] === vertices[vtx3 * 3] && vertices[vtx1 * 3 + 1] === vertices[vtx3 * 3 + 1] && vertices[vtx1 * 3 + 2] === vertices[vtx3 * 3 + 2] || vertices[vtx2 * 3] === vertices[vtx3 * 3] && vertices[vtx2 * 3 + 1] === vertices[vtx3 * 3 + 1] && vertices[vtx2 * 3 + 2] === vertices[vtx3 * 3 + 2]);

            for (let i = 0; i < 3; i++)
            {
                mgm[i] = new THREE.Matrix4();
            }

            const minPatches = 0;
            const maxPatches = 26;
            const vertPerRow = segments + 1;
            let surfCount = 0;
            let vertCount = 0;
            let normCount = 0;
            let uvCount = 0;
            let indexCount = 0;

            for (let surf = minPatches; surf < maxPatches; surf++)
            {
                // get M * G * M matrix for x,y,z
                for (let i = 0; i < 3; i++)
                {
                    // get control patches
                    for (let r = 0; r < 4; r++)
                    {
                        for (let c = 0; c < 4; c++)
                        {
                            // transposed
                            g[c * 4 + r] = teacupVertices[(teacupPatches[surf * 16 + r * 4 + c] - 1) * 3 + i];
                        }
                    }
                    gmx.set(g[0], g[1], g[2], g[3], g[4], g[5], g[6], g[7], g[8], g[9], g[10], g[11], g[12], g[13], g[14], g[15]);
                    tmtx.multiplyMatrices(gmx, ms);
                    mgm[i].multiplyMatrices(mst, tmtx);
                } // step along, get points, and output


                for (let sstep = 0; sstep <= segments; sstep++)
                {
                    const s = sstep / segments;
                    for (let tstep = 0; tstep <= segments; tstep++)
                    {
                        const t = tstep / segments; // point from basis
                        // get power vectors and their derivatives
                        for (p = 4, sval = tval = 1.0; p--;)
                        {
                            sp[p] = sval;
                            tp[p] = tval;
                            sval *= s;
                            tval *= t;

                            if (p === 3)
                            {
                                dsp[p] = dtp[p] = 0.0;
                                dsval = dtval = 1.0;
                            } else
                            {
                                dsp[p] = dsval * (3 - p);
                                dtp[p] = dtval * (3 - p);
                                dsval *= s;
                                dtval *= t;
                            }
                        }

                        vsp.fromArray(sp);
                        vtp.fromArray(tp);
                        vdsp.fromArray(dsp);
                        vdtp.fromArray(dtp); // do for x,y,z

                        for (let i = 0; i < 3; i++)
                        {
                            // multiply power vectors times matrix to get value
                            tcoord = vsp.clone();
                            tcoord.applyMatrix4(mgm[i]);
                            vert[i] = tcoord.dot(vtp); // get s and t tangent vectors

                            tcoord = vdsp.clone();
                            tcoord.applyMatrix4(mgm[i]);
                            sdir[i] = tcoord.dot(vtp);
                            tcoord = vsp.clone();
                            tcoord.applyMatrix4(mgm[i]);
                            tdir[i] = tcoord.dot(vdtp);
                        } // find normal


                        vsdir.fromArray(sdir);
                        vtdir.fromArray(tdir);
                        norm.crossVectors(vtdir, vsdir);
                        norm.normalize(); // if X and Z length is 0, at the cusp, so point the normal up or down, depending on patch number

                        if (vert[0] === 0 && vert[1] === 0)
                        {
                            // if above the middle of the teacup, normal points up, else down
                            normOut.set(0, vert[2] > maxHeight2 ? 1 : - 1, 0);
                        } else
                        {
                            // standard output: rotate on X axis
                            normOut.set(norm.x, norm.z, - norm.y);
                        }   // store it all

                        vertices[vertCount++] = trueSize * vert[0];
                        vertices[vertCount++] = trueSize * (vert[2] - maxHeight2);
                        vertices[vertCount++] = - trueSize * vert[1];
                        normals[normCount++] = normOut.x;
                        normals[normCount++] = normOut.y;
                        normals[normCount++] = normOut.z;
                        uvs[uvCount++] = 1 - t;
                        uvs[uvCount++] = 1 - s;
                    }
                } // save the faces

                for (let sstep = 0; sstep < segments; sstep++)
                {
                    for (let tstep = 0; tstep < segments; tstep++)
                    {
                        const v1 = surfCount * vertPerRow * vertPerRow + sstep * vertPerRow + tstep;
                        const v2 = v1 + 1;
                        const v3 = v2 + vertPerRow;
                        const v4 = v1 + vertPerRow;

                        // Normals and UVs cannot be shared. Without clone(), you can see the consequences
                        // of sharing if you call geometry.applyMatrix4( matrix ).
                        if (notDegenerate(v1, v2, v3))
                        {
                            indices[indexCount++] = v1;
                            indices[indexCount++] = v2;
                            indices[indexCount++] = v3;
                        }

                        if (notDegenerate(v1, v3, v4))
                        {
                            indices[indexCount++] = v1;
                            indices[indexCount++] = v3;
                            indices[indexCount++] = v4;
                        }
                    }
                } // increment only if a surface was used
                surfCount++;
            }

            this.setIndex(new THREE.BufferAttribute(indices, 1));
            this.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            this.setAttribute('normal', new THREE.BufferAttribute(normals, 3));
            this.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
            this.computeBoundingSphere();
        }
    }

    THREE.TeacupGeometry = TeacupGeometry;
})();
